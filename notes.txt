/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   notes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: llethuil <llethuil@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/23 16:27:19 by llethuil          #+#    #+#             */
/*   Updated: 2022/03/23 19:04:35 by llethuil         ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

# include "incs/main.h"
# include "/libft/libft.h"

1) Passer input dans tous les safe_malloc

	==================== FROM MAIN --> SHELL_INIT ====================

	NOEUD 1 :	input->garbage = ft_malloc(input, sizeof(t_garbage_lst), 1);
				input->garbage->type = COLLECTOR_LST;

	NOEUD 2 :	init_env(input, envp);
					input->env_tab = ft_malloc(input, sizeof(t_env), i);
					input->garbage->type = ENV_STRUCT;

	NOEUD 3 :	init_env(input, envp);
					input->env_tab[j].key = find_key(input, envp[i]);
						key = ft_substr(input, str, 0, i);
							ft_substr = ft_malloc(input, sizeof(char), (ft_strlen(s) + 1));
							ou
							ft_substr = ft_malloc(input, sizeof(char), (len + 1));
						input->garbage->type = ENV_STRUCT;

	NOEUD 4 :	init_env(input, envp);
					input->env_tab[j].value = find_value(input, envp[i]);
						value = ft_substr(input, str, key_count + 1, i);
							ft_substr = ft_malloc(input, sizeof(char), (ft_strlen(s) + 1));
							ou
							ft_substr = ft_malloc(input, sizeof(char), (len + 1));
						input->garbage->type = ENV_STRUCT;

	NOEUD 5 :	init_shlvl(input);
					value = ft_itoa(input, input->start_shlvl);
						nbr_str = ft_malloc(input, sizeof(char), i + 1);
					change_value(input, "SHLVL", value);
						input->env_tab[i].value = value;
					input->garbage->type = ENV_STRUCT;

	NOEUD 6 :	init_history(input);
					path = get_history_path(input);
						path = ft_strjoin(input, get_value("HOME", input), "/.minishelled_history");
							joined = ft_malloc(input, sizeof(char), len + 1);
						input->garbage->type = GARBAGE;

	NOEUD 7 :	init_history(input);
					cmd_line_history = ft_get_next_line(input, input->fd_history);
						line = ft_malloc(input, sizeof(char), 1);
						input->garbage->type = GARBAGE;
						line = ft_get_line(input, line, buff, fd);
							line = ft_strjoin_gnl(input, line, buff);
								joined = ft_malloc(input, sizeof(char), ft_strlen(line) + buff_size + 1);
						input->garbage->type = GARBAGE;
				!!!!! Voir quoi faire en cas de read_ret = -1 dans ft_get_line !!!

	==================== FROM MAIN --> CMD_LINE_MANAGER ====================

	NOEUD 8 :	get_cmd_line(input);
					path = get_history_path(input);
						path = ft_strjoin(input, get_value("HOME", input), "/.minishelled_history");
							joined = ft_malloc(input, sizeof(char), len + 1);
						input->garbage->type = GARBAGE;

	NOEUD 9 :	get_cmd_line(input);
					input->cmd_line = ft_strdup(buff);
						str = ft_malloc(input, sizeof(char), ft_strlen(s1) + 1);
					input->garbage->type = INPUT_STRUCT;
					!!!!! Voir quoi faire si input->fd_history < 0 !!!!!

	NOEUD 10 :	env_converter(input, input->cmd_line);
					size += count_env(str, &i, 0, input);
						key = ft_calloc(input, sizeof(char), key_len + 1);
						input->garbage->type = GARBAGE;

	NOEUD 11 :	env_converter(input, input->cmd_line);
				input->processed_line = ft_calloc(input, sizeof(char), size + 1);
				input->garbage->type = INPUT_STRUCT;

	NOEUD 12 :	env_converter(input, input->cmd_line);
					fill_buffer(input, str);
						fill_env(input, str, &i, &j);
						key = ft_substr(input, str, start, *i - start);
							ft_substr = ft_malloc(input, sizeof(char), (ft_strlen(s) + 1));
							ou
							ft_substr = ft_malloc(input, sizeof(char), (len + 1));
						input->garbage->type = GARBAGE;

	NOEUD 13 :	input->cmd_line = ft_strdup(input, input->processed_line);
					str = ft_malloc(input, sizeof(char), ft_strlen(s1) + 1);
				input->garbage->type = INPUT_STRUCT;

	FROM MAIN --> CMD_SEPARATOR

	NOEUD 13 :	single_cmd(input);
				input->cmd_tab = ft_malloc (input, sizeof(char *), 2);
				input->garbage->type = INPUT_STRUCT;

	NOEUD 14 :	single_cmd(input);
					input->cmd_tab[0] = ft_strtrim(input, input->cmd_line, " \t\n\v\f\r");
						trimmed = ft_malloc (input, sizeof(char), end - start + 1);
				input->garbage->type = INPUT_STRUCT;

	NOEUD 15 :	split_multi_cmd(input);
					fill_last_pipe(input);
						filled_cmd = ft_strjoin(input, input->cmd_line, line);
							joined = ft_malloc(input, sizeof(char), len + 1);
						input->garbage->type = GARBAGE;

	NOEUD 16 :	split_multi_cmd(input);
					fill_last_pipe(input);
						env_converter (filled_cmd, input);
						input->processed_line = ft_calloc(input, sizeof(char), size + 1);
						input->garbage->type = INPUT_STRUCT;

	NOEUD 17 :	split_multi_cmd(input);
					fill_last_pipe(input);
						env_converter(input, input->cmd_line);
							fill_buffer(input, str);
								fill_env(input, str, &i, &j);
								key = ft_substr(input, str, start, *i - start);
									ft_substr = ft_malloc(input, sizeof(char), (ft_strlen(s) + 1));
									ou
									ft_substr = ft_malloc(input, sizeof(char), (len + 1));
								input->garbage->type = GARBAGE;

	NOEUD 18 :	split_multi_cmd(input);
					fill_last_pipe(input);
						input->cmd_line = ft_strdup(input, input->processed_line);
							str = ft_malloc(input, sizeof(char), ft_strlen(s1) + 1);
						input->garbage->type = INPUT_STRUCT;

	NOEUD 19 :	split_multi_cmd(input);
					input->cmd_tab = ft_split(input, input->cmd_line, '|');
						table = ft_calloc(input, sizeof(char *), words + 1);
						ft_calloc_strs(input, s, c, table);
							table[i_table] = ft_calloc(input, sizeof(char), j_table + 1);
							input->garbage->type = INPUT_STRUCT;
					input->garbage->type = INPUT_STRUCT;

	NOEUD 20 :	split_multi_cmd(input);
					input->cmd_tab[i] = ft_strtrim(input, input->cmd_tab[i], " \t\n\v\f\r");
						trimmed = ft_malloc (input, sizeof(char), end - start + 1);
					input->garbage->type = INPUT_STRUCT;

	!!!!! VOIR SI ON A TOUJOURS BESOIN DE FREE ALL DANS CMD_SEPARATOR !!!!!

	==================== FROM MAIN --> REDIR_COLLECTOR ====================

	NOEUD 21 :	get_last_redir_type_tab(input);
					input->last_input_type_tab = ft_calloc(input, sizeof(int), input->n_cmd);
					input->garbage->type = INPUT_STRUCT;

	NOEUD 22 :	get_last_redir_type_tab(input);
					input->last_output_type_tab = ft_calloc(input, sizeof(int), input->n_cmd);
					input->garbage->type = INPUT_STRUCT;

	NOEUD 23 :	malloc_cmd_dimension(input);
					input->redir_tab = ft_malloc(input, sizeof(char ***), input->n_cmd + 1);
					input->garbage->type = INPUT_STRUCT;

	NOEUD 24 :	malloc_types_dimension_for_each_cmd(input);
					input->redir_tab[i_cmd] = ft_malloc(input, sizeof(char **), 5);
					input->garbage->type = INPUT_STRUCT;

	NOEUD 25 :	malloc_n_file_dimension_for_each_type(input, i_cmd, type);
					input->redir_tab[i_cmd][type] = ft_malloc(input, sizeof(char *), 1);
					input->garbage->type = INPUT_STRUCT;

	NOEUD 26 :	malloc_name_for_each_file(input, i_cmd, type, i_file);
					input->redir_tab[i_cmd][type][i_file] = ft_malloc(input, sizeof(char), len);
					input->garbage->type = INPUT_STRUCT;

	==================== FROM MAIN --> PARSER ====================

	!!!!!!!!!! VOIR COMMENT GERER LE RETURN SI CLEAN_CMD FAIL !!!!!!!!!!!
	NOEUD 27 :	clean_cmd(input)
					input->cmd_exec_tab = ft_calloc(input, sizeof(char **), input->n_cmd + 1);
					input->garbage->type = INPUT_STRUCT;

	NOEUD 28 :	clean_cmd(input)
					input->cmd_exec_tab[i] = ft_calloc(input, sizeof(char *), len);
					input->garbage->type = INPUT_STRUCT;

	?????????? on pourrait pas modifier get_arg_num en get_arg_len que tu as deja codé ? si on passe un int * en param ??????????

	NOEUD 29 :	clean_cmd(input)
					create_arg_tab(input, i)
						input->cmd_exec_tab[i][j] = ft_calloc(input, sizeof(char), len);
						input->garbage->type = INPUT_STRUCT;


	==================== FROM MAIN --> CMD_LST_INIT ====================

	NOEUD 30 :	cmd_lst_init(&input, &cmd);







Fonctions de la libft réellement utilisées :
	ft_strlen
	ft_substr	(modifiée pour ft_malloc)
	ft_atoi
	ft_itoa		(modifiée pour ft_malloc)
	ft_strjoin	(modifiée pour ft_malloc)
	ft_strdup	(modifiée pour ft_malloc)
	ft_calloc	(modifiée pour ft_malloc)
	ft_strtrim	(modifiée pour ft_malloc)
	ft_split	(modifiée pour ft_malloc)


2) modifier error_exit

3) voir tous les cas de return / exit (meme dans la libft !)